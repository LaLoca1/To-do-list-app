package api

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/LaLoca1/to-do-list-app-backend/internal/models"
	"github.com/gorilla/mux"
	"github.com/stretchr/testify/mock"
)

// MockTaskService is a mock implementation of TaskServiceInterface
type MockTaskService struct {
	mock.Mock
}

func (m *MockTaskService) GetTasks() ([]models.Task, error) {
	args := m.Called()
	return args.Get(0).([]models.Task), args.Error(1)
}

func (m *MockTaskService) CreateTask(task *models.Task) error {
	args := m.Called(task)
	return args.Error(0)
}

func (m *MockTaskService) UpdateTask(id int64, task *models.Task) error {
	args := m.Called(id, task)
	return args.Error(0)
}

func (m *MockTaskService) DeleteTask(id int64) error {
	args := m.Called(id)
	return args.Error(0)
}

func TestTaskHandler_GetTasks(t *testing.T) {
	// Creates new instance of MockTestService (mock implementation of service layer). Created to simulate behavior of GetTasks service method
	mockService := new(MockTaskService)
	// Defines a list of mock tasks (mockTasks) that represent the data the service would return. Each task is an instance of models.task struct
	mockTasks := []models.Task{
		{ID: 1, Title: "Task 1", Description: "Description 1", Completed: false},
		{ID: 2, Title: "Task 2", Description: "Description 2", Completed: true},
	}
	// Configures mock service to expect call to GetTasks method & return mockTasks(predefined task list) & nil (indicating no error occured)
	mockService.On("GetTasks").Return(mockTasks, nil)
	
	// Taskhandler is initialized with the mock service. Allows the handler to use the mocked behavior during the test
	handler := NewTaskHandler(mockService)

	// A new HTTP GET request is created to simulate a client requesting the /tasks endpoint
	// The request body is nil because a GET request does not require a body
	req, err := http.NewRequest("GET", "/tasks", nil)
	if err != nil {
		t.Fatalf("could not create request: %v", err)
	}

	// Creates a response recorder (rr) to capture the response generated by the handler
	// The GetTasks handler is invoked with the recorder and the request
	rr := httptest.NewRecorder()
	handler.GetTasks(rr, req)

	// Status code of the response (rr.code) is compared to http.StatusOK(200)
	if status := rr.Code; status != http.StatusOK {
		t.Errorf("expected status %v, got %v", http.StatusOK, status)
	}

	// Response body is decoded from JSON into a tasks slice of models.task. If decoding fails, test logs an error and fails
	var tasks []models.Task
	if err := json.NewDecoder(rr.Body).Decode(&tasks); err != nil {
		t.Fatalf("could not decode response body: %v", err)
	}

	// The length of the tasks returned in the response is compared to the mock data(mockTasks). 
	if len(tasks) != len(mockTasks) {
		t.Errorf("expected %d tasks, got %d", len(mockTasks), len(tasks))
	}

	// Ensures the GetTasks method of the mock service was called as expected
	mockService.AssertExpectations(t)
}

func TestTaskHandler_CreateTask(t *testing.T) {
	mockService := new(MockTaskService)
	newTask := models.Task{Title: "New Task", Description: "Test Description", Completed: false}
	// Configures the mock service to expect a call to its CreateTask method with newTask as the argument
	// The mock service will return nil (no error) when this method is called, simulating a successful task creation
	mockService.On("CreateTask", &newTask).Return(nil)

	handler := NewTaskHandler(mockService)
	// Converts the newTask object into JSON format for use as request body 
	// Simulates client sending a properly formatted JSON payload in the request. 
	requestBody, _ := json.Marshal(newTask)
	// Creates HTTP POST request to /tasks endpoint, with requestBody as payload
	req, err := http.NewRequest("POST", "/tasks", bytes.NewBuffer(requestBody))
	if err != nil {
		t.Fatalf("could not create request: %v", err)
	}
	// adds this header to the request to indicate that the body contains JSON data
	req.Header.Set("Content-Type", "application/json")

	rr := httptest.NewRecorder()
	handler.CreateTask(rr, req)

	if status := rr.Code; status != http.StatusCreated {
		t.Errorf("expected status %v, got %v", http.StatusCreated, status)
	}

	var createdTask models.Task
	if err := json.NewDecoder(rr.Body).Decode(&createdTask); err != nil {
		t.Fatalf("could not decode response body: %v", err)
	}

	if createdTask.Title != newTask.Title || createdTask.Description != newTask.Description || createdTask.Completed != newTask.Completed {
		t.Errorf("expected task %+v, got %+v", newTask, createdTask)
	}

	mockService.AssertExpectations(t)
}

func TestTaskHandler_UpdateTask(t *testing.T) {
	mockService := new(MockTaskService)
	updatedTask := models.Task{Title: "Updated Task", Description: "Updated Description", Completed: true}
	mockService.On("UpdateTask", int64(1), &updatedTask).Return(nil)

	handler := NewTaskHandler(mockService)
	reqBody, _ := json.Marshal(updatedTask)
	req, err := http.NewRequest("PUT", "/tasks/1", bytes.NewBuffer(reqBody))
	if err != nil {
		t.Fatalf("could not create request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")

	rr := httptest.NewRecorder()

	// This creates a map where: 
	// - The key is "id" representing a URL variable. The value is "1" representing the URL variable 
	// Mimics a scenario where the URL path includes a variable, such as /tasks/{id}, with {id} being replaced by 1
	vars := map[string]string{"id": "1"}

	//Uses mux.SetURLVars (a helper function from the Gorilla Mux package) to associate the vars map with the req (HTTP request).
	// This simulates having URL path parameters in the request, which are typically captured when a request goes through Gorilla Mux's routing system.
	// For example, if the route is /tasks/{id}, and a request is made to /tasks/1, Gorilla Mux internally stores id: "1" as a path variable. 
	// The SetURLVars function mimics this behavior in tests.
	req = mux.SetURLVars(req, vars)

	handler.UpdateTask(rr, req)

	if status := rr.Code; status != http.StatusOK {
		t.Errorf("expected status %v, got %v", http.StatusOK, status)
	}

	var returnedTask models.Task
	if err := json.NewDecoder(rr.Body).Decode(&returnedTask); err != nil {
		t.Fatalf("could not decode response body: %v", err)
	}

	if returnedTask.Title != updatedTask.Title || returnedTask.Description != updatedTask.Description || returnedTask.Completed != updatedTask.Completed {
		t.Errorf("expected task %+v, got %+v", updatedTask, returnedTask)
	}

	mockService.AssertExpectations(t)
}

func TestTaskHandler_DeleteTask(t *testing.T) {
	mockService := new(MockTaskService)
	mockService.On("DeleteTask", int64(1)).Return(nil)

	handler := NewTaskHandler(mockService)
	req, err := http.NewRequest("DELETE", "/tasks/1", nil)
	if err != nil {
		t.Fatalf("could not create request: %v", err)
	}

	rr := httptest.NewRecorder()

	vars := map[string]string{"id": "1"}
	req = mux.SetURLVars(req, vars)

	handler.DeleteTask(rr, req)

	if status := rr.Code; status != http.StatusNoContent {
		t.Errorf("expected status %v, got %v", http.StatusNoContent, status)
	}

	mockService.AssertExpectations(t)
}
